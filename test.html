<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Secret Santa 3D</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Times New Roman', serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* UI Overlay */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none;
            display: flex; flex-direction: column; align-items: center;
            padding-top: 40px; box-sizing: border-box;
            transition: opacity 0.5s ease;
        }
        
        .ui-hidden { opacity: 0; pointer-events: none !important; }

        /* Loader & Error Screens */
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 100;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 0.8s ease-out;
        }
        .loader-text {
            color: #d4af37; font-size: 14px; letter-spacing: 4px; margin-top: 20px;
            text-transform: uppercase; font-weight: 100;
        }
        .spinner {
            width: 40px; height: 40px; border: 1px solid rgba(212, 175, 55, 0.2); 
            border-top: 1px solid #d4af37; border-radius: 50%; 
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        #reset-btn {
            margin-top: 30px; padding: 10px 20px;
            border: 1px solid #ff4444; color: #ff4444; background: rgba(50,0,0,0.5);
            cursor: pointer; text-transform: uppercase; font-size: 12px; letter-spacing: 2px;
            display: none; pointer-events: auto; z-index: 200;
        }
        #reset-btn:hover { background: #ff4444; color: white; }

        #error-log {
            position: absolute; bottom: 0; left: 0; width: 100%; 
            background: rgba(50,0,0,0.8); color: #ffaaaa; 
            font-family: monospace; font-size: 10px; padding: 5px;
            display: none; z-index: 200;
        }

        /* Typography */
        h1 { 
            color: #fceea7; font-size: 56px; margin: 0; font-weight: 400; 
            letter-spacing: 6px; 
            text-shadow: 0 0 50px rgba(252, 238, 167, 0.6); 
            background: linear-gradient(to bottom, #fff, #eebb66);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            font-family: 'Cinzel', 'Times New Roman', serif;
            opacity: 0.9; text-align: center;
        }

        /* Controls */
        .upload-wrapper {
            margin-top: 20px; pointer-events: auto; text-align: center;
            display: flex; gap: 15px; flex-direction: column; align-items: center;
        }
        
        .action-btn {
            background: rgba(20, 20, 20, 0.6); 
            border: 1px solid rgba(212, 175, 55, 0.4); 
            color: #d4af37; padding: 10px 25px; 
            cursor: pointer; text-transform: uppercase; letter-spacing: 3px; font-size: 10px;
            transition: all 0.4s; backdrop-filter: blur(5px);
        }
        .action-btn:hover { background: #d4af37; color: #000; box-shadow: 0 0 20px rgba(212, 175, 55, 0.5); }

        .hint-text {
            color: rgba(212, 175, 55, 0.8); font-size: 10px; margin-top: 8px; letter-spacing: 1px; text-transform: uppercase;
        }
        
        /* Gallery */
        #gallery-modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 200;
            display: flex; flex-direction: column; align-items: center;
            padding: 40px; box-sizing: border-box;
            opacity: 0; pointer-events: none; transition: opacity 0.3s ease;
        }
        #gallery-modal.active { opacity: 1; pointer-events: auto; }
        
        .modal-header {
            font-family: 'Cinzel', serif; color: #d4af37; font-size: 32px;
            margin-bottom: 30px; border-bottom: 1px solid #333;
            width: 100%; text-align: center; padding-bottom: 20px;
        }
        
        .gallery-grid {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 20px; width: 100%; max-width: 800px; overflow-y: auto; margin-bottom: 30px;
        }
        
        .gallery-item {
            position: relative; aspect-ratio: 1; border: 1px solid #444;
            border-radius: 4px; overflow: hidden; background: #111;
        }
        .gallery-item img { width: 100%; height: 100%; object-fit: cover; }
        
        .delete-btn {
            position: absolute; top: 5px; right: 5px;
            background: rgba(200, 0, 0, 0.8); color: white; border: none;
            width: 24px; height: 24px; border-radius: 50%;
            cursor: pointer; font-weight: bold;
            display: flex; align-items: center; justify-content: center;
        }
        .delete-btn:hover { background: red; }
        
        .gallery-name {
            position: absolute; bottom: 0; left: 0; width: 100%;
            background: rgba(0,0,0,0.7); color: #ccc; font-size: 10px;
            padding: 4px; box-sizing: border-box; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        }

        /* Status & Caption */
        #status-indicator {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            padding: 10px 20px; background: rgba(212, 175, 55, 0.1);
            border: 1px solid rgba(212, 175, 55, 0.3); color: #d4af37;
            font-size: 12px; letter-spacing: 2px; text-transform: uppercase;
            border-radius: 5px; backdrop-filter: blur(4px); pointer-events: none;
        }
        
        #photo-caption {
            position: absolute; bottom: 18%; left: 50%; transform: translateX(-50%);
            color: #fff; font-family: 'Cinzel', serif; font-size: 36px; font-weight: 700;
            text-shadow: 0 0 15px rgba(212, 175, 55, 0.8); text-align: center;
            pointer-events: none; opacity: 0; transition: all 0.8s ease; width: 100%;
        }
        .caption-visible { opacity: 1 !important; transform: translateX(-50%) translateY(0px) !important; }
        .caption-hidden { opacity: 0 !important; transform: translateX(-50%) translateY(20px) !important; }
        .caption-end {
            top: 50% !important; bottom: auto !important;
            transform: translate(-50%, -50%) !important;
            font-size: 50px !important; width: 90%;
        }
        
        #file-input, #gallery-input { display: none; }

        #webcam-wrapper {
            position: absolute; bottom: 40px; right: 40px;
            width: 160px; height: 120px; border: 1px solid rgba(255,255,255,0.1);
            overflow: hidden; opacity: 0.4; pointer-events: none; transition: opacity 0.5s ease;
        }
    </style>
    
    <style>@import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap');</style>

    <script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
    "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm",
    "react": "https://esm.sh/react@^19.2.3",
    "react-dom/": "https://esm.sh/react-dom@^19.2.3/",
    "react/": "https://esm.sh/react@^19.2.3/",
    "three/": "https://esm.sh/three@^0.182.0/"
  }
}
</script>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <div class="loader-text">Loading Holiday Magic</div>
        <button id="reset-btn" onclick="window.fullReset()">Reset App Data</button>
    </div>
    
    <div id="error-log"></div>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <h1>Merry Christmas</h1>
        <div class="upload-wrapper">
            <button class="action-btn" id="open-gallery-btn">Manage Photos</button>
            <div class="hint-text">
                <p>Fist: Tree | Open Hand: Scatter | Pinch: Pick Gift</p>
                <p>Press 'H' to hide UI</p>
            </div>
        </div>
    </div>

    <!-- Gallery Modal -->
    <div id="gallery-modal">
        <div class="modal-header">Memory Gallery</div>
        <div class="gallery-grid" id="gallery-grid"></div>
        <div style="display:flex; gap:15px;">
            <label class="action-btn">
                Add Photo <input type="file" id="gallery-input" multiple accept="image/*">
            </label>
            <button class="action-btn" id="close-gallery-btn">Close</button>
        </div>
    </div>
    
    <div id="photo-caption" class="caption-hidden"></div>
    <div id="status-indicator">Initializing...</div>

    <div id="webcam-wrapper">
        <video id="webcam" autoplay playsinline style="width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1);"></video>
    </div>

    <!-- Fallback Script for Reset and Errors -->
    <script>
        function logError(msg) {
            const el = document.getElementById('error-log');
            if(el) {
                el.style.display = 'block';
                el.innerText = "Error: " + msg;
            }
            console.error(msg);
        }

        window.fullReset = function() {
            if(confirm("Clear all data and reload? This fixes loading freeze.")) {
                localStorage.clear();
                window.location.reload();
            }
        };

        // Show reset button after 4 seconds automatically
        setTimeout(() => {
            const btn = document.getElementById('reset-btn');
            if(btn) btn.style.display = 'block';
        }, 4000);

        // Protocol Warning
        if (window.location.protocol === 'file:') {
            alert("⚠️ WARNING: You are opening this file directly.\nCamera features will NOT work due to browser security.\nPlease use a local server (like VS Code Live Server) or upload this file to a website.");
            logError("File protocol detected. Camera blocked.");
        }
        
        window.addEventListener('error', function(e) {
            logError(e.message);
        });
    </script>

    <!-- Main Application Logic -->
    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js'; 
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        // --- CONFIG ---
        const CONFIG = {
            colors: { bg: 0x000000, gold: 0xffd966, green: 0x03180a, red: 0x990000 },
            particles: { count: 1200, dust: 2000, treeH: 24, treeR: 8 },
            cameraZ: 50,
            storageKey: 'secret_santa_v3'
        };

        const STATE = {
            mode: 'TREE',
            focusTarget: null, focusName: '',
            hand: { detected: false, x: 0, y: 0 },
            rot: { x: 0, y: 0 },
            lastGesture: 'NONE',
            canPinch: true
        };

        let scene, camera, renderer, composer, mainGroup, photoGroup;
        let particles = [], photoParticles = [];
        let clock = new THREE.Clock();
        let handLandmarker, videoElement;
        let caneTexture;

        // --- CORE FUNCTIONS ---
        async function init() {
            try {
                initThree();
                createObjects();
                setupUI();
                
                // Start Loop immediately so we see something
                animate();

                // Load Data (Non-blocking)
                loadPhotos().catch(e => console.error("Photo load error", e));
                
                // Hide Loader
                document.getElementById('loader').style.opacity = 0;
                setTimeout(() => document.getElementById('loader').style.display = 'none', 800);

                // Initialize AI (Heavy task)
                initMediaPipe();

            } catch (e) {
                alert("Init failed: " + e.message);
            }
        }

        function initThree() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.colors.bg);
            scene.fog = new THREE.FogExp2(CONFIG.colors.bg, 0.015);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, CONFIG.cameraZ);

            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ReinhardToneMapping;
            renderer.toneMappingExposure = 2.0;
            container.appendChild(renderer.domElement);

            mainGroup = new THREE.Group();
            scene.add(mainGroup);
            photoGroup = new THREE.Group();
            mainGroup.add(photoGroup);

            // Post Processing
            const renderPass = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.7; bloomPass.strength = 0.4; bloomPass.radius = 0.5;
            
            composer = new EffectComposer(renderer);
            composer.addPass(renderPass);
            composer.addPass(bloomPass);

            // Lighting
            const pmrem = new THREE.PMREMGenerator(renderer);
            scene.environment = pmrem.fromScene(new RoomEnvironment(), 0.04).texture;
            
            scene.add(new THREE.AmbientLight(0xffffff, 0.5));
            const spot = new THREE.SpotLight(0xffcc66, 1000);
            spot.position.set(30, 40, 40);
            scene.add(spot);
            
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function createObjects() {
            // Textures
            const cvs = document.createElement('canvas'); cvs.width=64; cvs.height=64;
            const ctx = cvs.getContext('2d');
            ctx.fillStyle='#fff'; ctx.fillRect(0,0,64,64);
            ctx.fillStyle='#a00'; ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(16,0); ctx.lineTo(64,48); ctx.lineTo(64,64); ctx.lineTo(48,64); ctx.lineTo(0,16); ctx.fill();
            caneTexture = new THREE.CanvasTexture(cvs);
            caneTexture.wrapS = caneTexture.wrapT = THREE.RepeatWrapping;

            // Geometry Shared
            const boxGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            const sphereGeo = new THREE.SphereGeometry(0.4, 16, 16);
            
            const matGold = new THREE.MeshStandardMaterial({ color: CONFIG.colors.gold, metalness: 1, roughness: 0.1 });
            const matGreen = new THREE.MeshStandardMaterial({ color: CONFIG.colors.green, metalness: 0.2, roughness: 0.8 });
            const matRed = new THREE.MeshPhysicalMaterial({ color: CONFIG.colors.red, metalness: 0.4, roughness: 0.2, clearcoat: 1 });

            // Create Standard Particles
            for(let i=0; i<CONFIG.particles.count; i++) {
                const r = Math.random();
                let mesh, type;
                if(r<0.4) { mesh = new THREE.Mesh(boxGeo, matGreen); type = 'BOX'; }
                else if(r<0.7) { mesh = new THREE.Mesh(boxGeo, matGold); type = 'GOLD_BOX'; }
                else if(r<0.95) { mesh = new THREE.Mesh(sphereGeo, matGold); type = 'SPHERE'; }
                else { mesh = new THREE.Mesh(sphereGeo, matRed); type = 'RED'; }
                
                mesh.scale.setScalar(0.5 + Math.random()*0.5);
                mesh.rotation.set(Math.random()*3, Math.random()*3, Math.random()*3);
                
                mainGroup.add(mesh);
                particles.push(new Particle(mesh, type));
            }

            // Star
            const star = new THREE.Mesh(new THREE.OctahedronGeometry(1.5, 0), new THREE.MeshBasicMaterial({color: 0xffdd88}));
            star.position.y = CONFIG.particles.treeH/2 + 1.5;
            mainGroup.add(star);
        }

        // --- PARTICLE LOGIC ---
        class Particle {
            constructor(mesh, type, name="") {
                this.mesh = mesh;
                this.type = type;
                this.name = name;
                this.baseScale = mesh.scale.x;
                this.isDrawn = false;
                
                // Tree Pos
                const h = CONFIG.particles.treeH;
                const t = Math.pow(Math.random(), 0.8);
                const y = (t * h) - (h/2);
                const r = (CONFIG.particles.treeR * (1-t)) * (0.8 + Math.random()*0.4);
                const a = t * 40 + Math.random() * 3;
                this.posTree = new THREE.Vector3(Math.cos(a)*r, y, Math.sin(a)*r);
                
                // Scatter Pos
                const rs = 10 + Math.random() * 15;
                const th = Math.random() * Math.PI * 2;
                const ph = Math.acos(2*Math.random()-1);
                this.posScatter = new THREE.Vector3(rs*Math.sin(ph)*Math.cos(th), rs*Math.sin(ph)*Math.sin(th), rs*Math.cos(ph));
                
                this.mesh.position.copy(this.posTree);
            }

            update(dt, mode) {
                const target = new THREE.Vector3();
                let opacity = 1.0;
                let s = this.baseScale;

                // Mode Logic
                if (mode === 'TREE' || mode === 'END_GAME') target.copy(this.posTree);
                else if (mode === 'SCATTER') target.copy(this.posScatter);
                else if (mode === 'FOCUS') {
                    if (this.mesh === STATE.focusTarget) {
                        const inv = mainGroup.matrixWorld.clone().invert();
                        const worldTarget = new THREE.Vector3(0, 1.5, CONFIG.cameraZ - 8);
                        target.copy(worldTarget.applyMatrix4(inv));
                        s = 5.0;
                        // Face Camera
                        this.mesh.quaternion.slerp(camera.quaternion, 0.1);
                    } else {
                        target.copy(this.posScatter);
                        opacity = 0.1;
                        if(this.type === 'PHOTO' && this.isDrawn) {
                            opacity = 0.05;
                            target.multiplyScalar(1.5);
                        }
                    }
                }

                if(this.mesh.material.transparent) this.mesh.material.opacity += (opacity - this.mesh.material.opacity) * dt * 4;
                
                // Move
                const speed = (mode === 'FOCUS' && this.mesh === STATE.focusTarget) ? 4 : 1.5;
                this.mesh.position.lerp(target, dt * speed);
                this.mesh.scale.lerp(new THREE.Vector3(s,s,s), dt * 3);
                
                // Rotate
                if (mode !== 'FOCUS' || this.mesh !== STATE.focusTarget) {
                    this.mesh.rotation.y += dt * 0.5;
                }
            }
        }

        // --- PHOTOS ---
        async function loadPhotos() {
            let data = [];
            try {
                const stored = localStorage.getItem(CONFIG.storageKey);
                if(stored) data = JSON.parse(stored);
            } catch(e) { console.error(e); }

            if(data.length === 0) {
                createDefaultPhoto();
            } else {
                for(let p of data) {
                   await addPhoto(p.data, p.name, p.id); 
                }
            }
            updateGalleryUI();
        }

        function createDefaultPhoto() {
            const cvs = document.createElement('canvas'); cvs.width=512; cvs.height=512;
            const ctx = cvs.getContext('2d');
            ctx.fillStyle='#111'; ctx.fillRect(0,0,512,512);
            ctx.strokeStyle='#da0'; ctx.lineWidth=20; ctx.strokeRect(20,20,472,472);
            ctx.fillStyle='#da0'; ctx.font='60px serif'; ctx.textAlign='center';
            ctx.fillText("JOYEUX", 256, 220); ctx.fillText("NOEL", 256, 300);
            
            new THREE.TextureLoader().load(cvs.toDataURL(), t => {
                t.colorSpace = THREE.SRGBColorSpace;
                addPhotoToGroup(t, "Welcome", "default");
            });
        }

        function addPhoto(dataUrl, name, id) {
            return new Promise(resolve => {
                new THREE.TextureLoader().load(dataUrl, t => {
                    t.colorSpace = THREE.SRGBColorSpace;
                    addPhotoToGroup(t, name, id);
                    resolve();
                }, undefined, () => resolve()); // Resolve even on error to prevent freeze
            });
        }

        function addPhotoToGroup(tex, name, id) {
            const group = new THREE.Group();
            
            // Frame
            const frame = new THREE.Mesh(
                new THREE.BoxGeometry(1.2, 1.2, 0.05),
                new THREE.MeshStandardMaterial({color: CONFIG.colors.gold, metalness:1, roughness:0.2})
            );
            
            // Photo
            const plane = new THREE.Mesh(
                new THREE.PlaneGeometry(1, 1),
                new THREE.MeshBasicMaterial({map: tex})
            );
            plane.position.z = 0.03;
            
            group.add(frame);
            group.add(plane);
            photoGroup.add(group);
            
            const p = new Particle(group, 'PHOTO', name);
            p.id = id;
            particles.push(p);
            photoParticles.push(p);
        }

        // --- MEDIAPIPE AI ---
        async function initMediaPipe() {
            videoElement = document.getElementById('webcam');
            const status = document.getElementById('status-indicator');
            
            if (!navigator.mediaDevices?.getUserMedia) {
                status.innerText = "Camera API unavailable";
                return;
            }

            try {
                const vision = await FilesetResolver.forVisionTasks(
                    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
                );
                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO",
                    numHands: 1
                });

                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                videoElement.srcObject = stream;
                videoElement.addEventListener("loadeddata", () => {
                    status.innerText = "Camera Active - Wave Hand";
                    predictWebcam();
                });

            } catch (err) {
                console.error(err);
                status.innerText = "Gesture Error (Check Console)";
                document.getElementById('error-log').innerText = err.message;
                document.getElementById('error-log').style.display = 'block';
            }
        }

        let lastVideoTime = -1;
        async function predictWebcam() {
            if (handLandmarker && videoElement.currentTime !== lastVideoTime) {
                lastVideoTime = videoElement.currentTime;
                const result = handLandmarker.detectForVideo(videoElement, performance.now());
                
                if (result.landmarks.length > 0) {
                    const lm = result.landmarks[0];
                    STATE.hand.detected = true;
                    // Map hand coords (0-1) to rotation (-PI to PI)
                    STATE.hand.x = (lm[9].x - 0.5) * 2; 
                    STATE.hand.y = (lm[9].y - 0.5) * 2;
                    detectGesture(lm);
                } else {
                    STATE.hand.detected = false;
                }
            }
            requestAnimationFrame(predictWebcam);
        }

        function detectGesture(lm) {
            const dist = (i, j) => Math.hypot(lm[i].x-lm[j].x, lm[i].y-lm[j].y);
            
            const thumbTip = lm[4], indexTip = lm[8];
            const pinch = dist(4, 8) < 0.05;
            
            // Average finger extension
            const fingersOpen = (dist(8,0) + dist(12,0) + dist(16,0) + dist(20,0)) / 4 > 0.4;
            const fingersClosed = (dist(8,0) + dist(12,0) + dist(16,0) + dist(20,0)) / 4 < 0.25;

            let gesture = 'NONE';
            if (pinch) gesture = 'PINCH';
            else if (fingersOpen) gesture = 'OPEN';
            else if (fingersClosed) gesture = 'FIST';

            handleStateTransition(gesture);
        }

        function handleStateTransition(gesture) {
            const status = document.getElementById('status-indicator');
            const caption = document.getElementById('photo-caption');

            if (STATE.mode === 'FOCUS') {
                if (gesture === 'FIST') {
                    STATE.mode = 'TREE';
                    STATE.focusTarget = null;
                    status.innerText = "Mode: Tree";
                    caption.classList.remove('caption-visible');
                    caption.classList.add('caption-hidden');
                }
                return;
            }

            if (STATE.mode === 'END_GAME') return;

            if (gesture === 'PINCH' && STATE.canPinch) {
                const undrawn = photoParticles.filter(p => !p.isDrawn);
                if (undrawn.length > 0) {
                    const p = undrawn[Math.floor(Math.random()*undrawn.length)];
                    p.isDrawn = true;
                    STATE.mode = 'FOCUS';
                    STATE.focusTarget = p.mesh;
                    
                    status.innerText = "Gift Opened! (Fist to Close)";
                    caption.innerText = p.name;
                    caption.classList.remove('caption-hidden');
                    caption.classList.add('caption-visible');
                } else {
                    STATE.mode = 'END_GAME';
                    status.innerText = "Merry Christmas!";
                    caption.innerText = "Merry Christmas!";
                    caption.classList.add('caption-end');
                }
                STATE.canPinch = false;
                setTimeout(() => STATE.canPinch = true, 2000);
            } 
            else if (gesture === 'OPEN') {
                STATE.mode = 'SCATTER';
                status.innerText = "Mode: Scatter (Move Hand)";
            }
            else if (gesture === 'FIST') {
                STATE.mode = 'TREE';
                status.innerText = "Mode: Tree";
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            
            // Rotation Logic
            let tx = 0, ty = 0;
            if(STATE.mode === 'SCATTER' && STATE.hand.detected) {
                ty = STATE.hand.x * 2; 
                tx = STATE.hand.y * 1;
            } else if(STATE.mode === 'TREE' || STATE.mode === 'END_GAME') {
                ty = STATE.rot.y + 0.3 * dt;
            } else if(STATE.mode === 'FOCUS') {
                ty = STATE.rot.y + 0.1 * dt;
            }
            
            STATE.rot.y += (ty - STATE.rot.y) * dt * 2;
            STATE.rot.x += (tx - STATE.rot.x) * dt * 2;

            mainGroup.rotation.y = STATE.rot.y;
            mainGroup.rotation.x = STATE.rot.x;
            mainGroup.updateMatrixWorld();

            particles.forEach(p => p.update(dt, STATE.mode));
            composer.render();
        }

        // --- UI HANDLERS ---
        function setupUI() {
            const galleryModal = document.getElementById('gallery-modal');
            
            document.getElementById('open-gallery-btn').onclick = () => {
                galleryModal.classList.add('active');
                updateGalleryUI();
            };
            document.getElementById('close-gallery-btn').onclick = () => {
                galleryModal.classList.remove('active');
            };
            
            document.getElementById('gallery-input').onchange = async (e) => {
                const files = e.target.files;
                if(!files.length) return;
                
                let stored = [];
                try { stored = JSON.parse(localStorage.getItem(CONFIG.storageKey) || '[]'); } catch {}

                for(let f of files) {
                    const reader = new FileReader();
                    reader.onload = (ev) => {
                        const img = new Image();
                        img.onload = () => {
                            // Simple compression
                            const cvs = document.createElement('canvas');
                            const scale = Math.min(800/img.width, 800/img.height, 1);
                            cvs.width = img.width * scale;
                            cvs.height = img.height * scale;
                            cvs.getContext('2d').drawImage(img,0,0,cvs.width,cvs.height);
                            
                            const data = cvs.toDataURL('image/jpeg', 0.7);
                            const id = Date.now() + Math.random();
                            const name = f.name.split('.')[0];
                            
                            addPhoto(data, name, id);
                            stored.push({id, name, data});
                            localStorage.setItem(CONFIG.storageKey, JSON.stringify(stored));
                            updateGalleryUI();
                        }
                        img.src = ev.target.result;
                    }
                    reader.readAsDataURL(f);
                }
            };
            
            window.addEventListener('keydown', e => {
                if(e.key.toLowerCase() === 'h') {
                    document.getElementById('ui-layer').classList.toggle('ui-hidden');
                    document.getElementById('status-indicator').classList.toggle('ui-hidden');
                }
            });
        }

        function updateGalleryUI() {
            const grid = document.getElementById('gallery-grid');
            grid.innerHTML = '';
            
            let stored = [];
            try { stored = JSON.parse(localStorage.getItem(CONFIG.storageKey) || '[]'); } catch {}
            
            if(stored.length === 0) grid.innerHTML = '<p style="color:#666;text-align:center;width:100%">No photos saved.</p>';

            stored.forEach(p => {
                const div = document.createElement('div');
                div.className = 'gallery-item';
                div.innerHTML = `<img src="${p.data}"><div class="gallery-name">${p.name}</div><button class="delete-btn">×</button>`;
                div.querySelector('button').onclick = () => {
                    if(confirm("Delete?")) {
                        stored = stored.filter(x => x.id !== p.id);
                        localStorage.setItem(CONFIG.storageKey, JSON.stringify(stored));
                        
                        // Remove from scene
                        const idx = particles.findIndex(x => x.id === p.id);
                        if(idx > -1) {
                            photoGroup.remove(particles[idx].mesh);
                            particles.splice(idx, 1);
                            photoParticles = photoParticles.filter(x => x.id !== p.id);
                        }
                        updateGalleryUI();
                    }
                };
                grid.appendChild(div);
            });
        }

        init();
    </script>
</body>
</html>
