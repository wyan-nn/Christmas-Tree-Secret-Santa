<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Secret Santa 3D - Final Fix</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Times New Roman', serif; }
        
        /* 3D Container */
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }

        /* UI Layer */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none;
            display: flex; flex-direction: column; align-items: center;
            transition: opacity 0.5s ease;
        }

        /* Loading Screen */
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 100;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 0.8s ease-out;
        }
        .spinner {
            width: 40px; height: 40px; border: 2px solid #333; 
            border-top: 2px solid #d4af37; border-radius: 50%; 
            animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Emergency Reset Button (Always visible initially) */
        #emergency-reset {
            position: fixed; top: 10px; left: 10px; z-index: 9999;
            background: rgba(100, 0, 0, 0.8); color: white;
            border: 1px solid red; padding: 8px 15px;
            font-size: 10px; cursor: pointer; text-transform: uppercase;
            pointer-events: auto; display: block;
        }
        #emergency-reset:hover { background: red; }

        /* Titles */
        h1 { 
            color: #fceea7; font-size: 5vw; margin-top: 40px; font-weight: 400; 
            letter-spacing: 0.2em; text-shadow: 0 0 30px rgba(252, 238, 167, 0.4); 
            font-family: serif; opacity: 0.9; text-align: center;
        }

        /* Controls */
        .controls {
            margin-top: 20px; pointer-events: auto; text-align: center;
            display: flex; flex-direction: column; align-items: center; gap: 10px;
        }
        
        .btn {
            background: rgba(20, 20, 20, 0.6); border: 1px solid #d4af37; 
            color: #d4af37; padding: 8px 20px; cursor: pointer; 
            text-transform: uppercase; letter-spacing: 2px; font-size: 10px;
            transition: 0.3s;
        }
        .btn:hover { background: #d4af37; color: #000; }

        .hints {
            color: rgba(212, 175, 55, 0.7); font-size: 10px; letter-spacing: 1px;
            margin-top: 10px; text-transform: uppercase; text-align: center;
        }

        /* Status & Caption */
        #status-bar {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            color: #d4af37; font-size: 12px; letter-spacing: 2px; text-transform: uppercase;
            text-shadow: 0 0 10px black; pointer-events: none;
        }
        #center-caption {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 100%; text-align: center; font-family: serif; font-size: 40px;
            color: white; pointer-events: none; opacity: 0; transition: opacity 0.5s;
            text-shadow: 0 0 20px gold; z-index: 5;
        }

        /* Gallery Modal */
        #gallery-modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 200;
            display: none; flex-direction: column; align-items: center; padding: 40px;
        }
        #gallery-grid {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 15px; width: 100%; max-width: 600px; max-height: 70vh; overflow-y: auto;
            margin: 20px 0;
        }
        .gallery-item { position: relative; border: 1px solid #444; }
        .gallery-item img { width: 100%; display: block; }
        .del-btn {
            position: absolute; top: 0; right: 0; background: red; color: white;
            border: none; cursor: pointer; width: 20px; height: 20px;
        }

        /* Webcam Preview (Small) */
        #webcam {
            position: absolute; bottom: 20px; right: 20px;
            width: 120px; opacity: 0.3; pointer-events: none;
            transform: scaleX(-1); border: 1px solid white;
        }
        
        #input-file { display: none; }
    </style>

    <!-- IMPORT MAP: Essential for 3D and AI -->
    <script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
    "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm",
    "react": "https://esm.sh/react@^19.2.3",
    "react-dom/": "https://esm.sh/react-dom@^19.2.3/",
    "react/": "https://esm.sh/react@^19.2.3/",
    "three/": "https://esm.sh/three@^0.182.0/"
  }
}
</script>
</head>
<body>

    <!-- Emergency Button: Works even if JS crashes -->
    <button id="emergency-reset" onclick="hardReset()">RESET FIX</button>

    <div id="loader">
        <div class="spinner"></div>
        <div style="color: #d4af37; letter-spacing: 2px;">LOADING...</div>
    </div>

    <div id="canvas-container"></div>
    <div id="center-caption"></div>
    <div id="status-bar">Initializing 3D Engine...</div>
    <video id="webcam" autoplay playsinline muted></video>

    <div id="ui-layer">
        <h1>MERRY CHRISTMAS</h1>
        <div class="controls">
            <button class="btn" onclick="openGallery()">Manage Photos</button>
            <div class="hints">
                Fist: Tree | Open: Scatter | Pinch: Pick Gift<br>
                Press 'H' to toggle UI
            </div>
        </div>
    </div>

    <!-- Gallery UI -->
    <div id="gallery-modal">
        <h2 style="color:#d4af37; margin-top:0;">Memories</h2>
        <div id="gallery-grid"></div>
        <div style="display:flex; gap:10px;">
            <button class="btn" onclick="document.getElementById('input-file').click()">Add Photo</button>
            <button class="btn" onclick="closeGallery()">Close</button>
        </div>
        <input type="file" id="input-file" multiple accept="image/*">
    </div>

    <!-- MAIN SCRIPT -->
    <script>
        // Global Reset Function
        window.hardReset = function() {
            if(confirm("Clear all data and reload? Use this if the app is frozen.")) {
                localStorage.clear();
                window.location.reload();
            }
        };
        // Auto-hide reset button after 8 seconds if successful
        setTimeout(() => {
            const btn = document.getElementById('emergency-reset');
            if(btn) btn.style.display = 'none';
        }, 8000);
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js'; 
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        // --- GLOBAL VARIABLES ---
        let scene, camera, renderer, composer;
        let mainGroup, photoGroup;
        let particles = [], photoParticles = [];
        let clock = new THREE.Clock();
        let handLandmarker;
        const CONFIG = {
            storageKey: 'secret_santa_fixed_v4',
            colors: { gold: 0xffd966, red: 0x990000, green: 0x03180a },
            count: 1200
        };
        const STATE = {
            mode: 'TREE',
            focusTarget: null,
            handDetected: false,
            targetRotY: 0,
            currentRotY: 0,
            canPinch: true
        };

        // --- 1. INITIALIZATION SEQUENCE ---
        async function init() {
            try {
                // Step 1: Init 3D Scene (Must happen first so screen isn't black)
                initThree();
                createParticles();
                animate(); // Start render loop immediately
                
                // Hide loader quickly
                const loader = document.getElementById('loader');
                loader.style.opacity = '0';
                setTimeout(() => loader.style.display = 'none', 500);

                // Step 2: Load Data (Async)
                await loadPhotosSafe();

                // Step 3: Init AI (Async, might fail on local files)
                document.getElementById('status-bar').innerText = "Loading Camera...";
                await initMediaPipe();
                document.getElementById('status-bar').innerText = "Ready! Show your hand.";

            } catch (e) {
                console.error(e);
                document.getElementById('status-bar').innerText = "Error: " + e.message;
            }
        }

        function initThree() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            scene.fog = new THREE.FogExp2(0x000000, 0.02);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 100);
            camera.position.set(0, 2, 40);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ReinhardToneMapping;
            container.appendChild(renderer.domElement);

            // Lighting
            const pmrem = new THREE.PMREMGenerator(renderer);
            scene.environment = pmrem.fromScene(new RoomEnvironment(), 0.04).texture;
            const spot = new THREE.SpotLight(0xffcc66, 500);
            spot.position.set(20, 40, 20);
            scene.add(spot);
            scene.add(new THREE.AmbientLight(0xffffff, 0.5));

            // Groups
            mainGroup = new THREE.Group();
            scene.add(mainGroup);
            photoGroup = new THREE.Group();
            mainGroup.add(photoGroup);

            // Post Processing
            const renderPass = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.6; bloomPass.strength = 0.5; bloomPass.radius = 0.5;
            composer = new EffectComposer(renderer);
            composer.addPass(renderPass);
            composer.addPass(bloomPass);

            // Events
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth/window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight);
            });
            
            window.addEventListener('keydown', (e) => {
                if(e.key.toLowerCase() === 'h') {
                    const ui = document.getElementById('ui-layer');
                    ui.style.opacity = ui.style.opacity === '0' ? '1' : '0';
                }
            });
        }

        // --- 2. OBJECT CREATION ---
        function createParticles() {
            const geo = new THREE.BoxGeometry(0.4, 0.4, 0.4);
            const matGold = new THREE.MeshStandardMaterial({ color: CONFIG.colors.gold, metalness: 1, roughness: 0.2 });
            const matGreen = new THREE.MeshStandardMaterial({ color: CONFIG.colors.green, metalness: 0.1, roughness: 0.8 });
            const matRed = new THREE.MeshStandardMaterial({ color: CONFIG.colors.red, metalness: 0.5, roughness: 0.2 });

            for(let i=0; i<CONFIG.count; i++) {
                let mesh;
                const r = Math.random();
                if(r < 0.6) mesh = new THREE.Mesh(geo, matGreen);
                else if(r < 0.85) mesh = new THREE.Mesh(geo, matGold);
                else mesh = new THREE.Mesh(geo, matRed);

                mesh.scale.setScalar(0.5 + Math.random()*0.5);
                mainGroup.add(mesh);
                
                // Calculate Positions
                const p = new Particle(mesh);
                particles.push(p);
            }

            // Star
            const star = new THREE.Mesh(new THREE.OctahedronGeometry(1.5,0), new THREE.MeshBasicMaterial({color: 0xffddaa}));
            star.position.y = 13;
            mainGroup.add(star);
        }

        class Particle {
            constructor(mesh, type='DECOR') {
                this.mesh = mesh;
                this.type = type;
                this.isDrawn = false;

                // Tree Position (Spiral)
                const h = 24;
                const t = Math.pow(Math.random(), 0.8);
                const y = (t * h) - (h/2);
                const r = (8 * (1-t)) * (0.8 + Math.random()*0.4);
                const a = t * 40 + Math.random() * 6;
                this.posTree = new THREE.Vector3(Math.cos(a)*r, y, Math.sin(a)*r);

                // Scatter Position
                const sr = 10 + Math.random() * 10;
                this.posScatter = new THREE.Vector3((Math.random()-0.5)*sr, (Math.random()-0.5)*sr, (Math.random()-0.5)*sr);

                this.mesh.position.copy(this.posTree);
            }

            update(dt) {
                const target = new THREE.Vector3();
                let s = this.mesh.geometry.type === 'PlaneGeometry' ? 1 : this.mesh.scale.x; 
                let opacity = 1.0;

                // Logic based on global MODE
                if (STATE.mode === 'TREE') target.copy(this.posTree);
                else if (STATE.mode === 'SCATTER') target.copy(this.posScatter);
                else if (STATE.mode === 'FOCUS') {
                    if (this.mesh === STATE.focusTarget) {
                        // Focus item moves to front
                        const inv = mainGroup.matrixWorld.clone().invert();
                        const worldTarget = new THREE.Vector3(0, 0, 32); // Close to camera
                        target.copy(worldTarget.applyMatrix4(inv));
                        s = 3.0; // Enlarge
                        this.mesh.lookAt(camera.position); // Face user
                    } else {
                        target.copy(this.posScatter); // Background scatters
                        opacity = 0.1; // Fade out
                    }
                }

                // Smooth Move
                this.mesh.position.lerp(target, dt * 2.5);
                
                // Smooth Rotate (idle)
                if (STATE.mode !== 'FOCUS' || this.mesh !== STATE.focusTarget) {
                    this.mesh.rotation.y += dt * 0.5;
                }
                
                // Opacity handling for Photos
                if (this.mesh.material.transparent) {
                    this.mesh.material.opacity += (opacity - this.mesh.material.opacity) * dt * 5;
                }
            }
        }

        // --- 3. PHOTO MANAGEMENT (SAFE) ---
        async function loadPhotosSafe() {
            let data = [];
            try {
                const json = localStorage.getItem(CONFIG.storageKey);
                if (json) data = JSON.parse(json);
            } catch (e) {
                console.warn("Corrupt storage, clearing.");
                localStorage.removeItem(CONFIG.storageKey);
            }

            if (data.length === 0) {
                createDefaultPhoto();
            } else {
                for (const item of data) {
                    // Load one by one, catch errors individually
                    try {
                        await addPhotoToScene(item.data, item.name, item.id);
                    } catch (err) {
                        console.warn("Skipping bad photo", err);
                    }
                }
            }
            updateGallery();
        }

        function createDefaultPhoto() {
            const cvs = document.createElement('canvas'); cvs.width=512; cvs.height=512;
            const ctx = cvs.getContext('2d');
            ctx.fillStyle='#111'; ctx.fillRect(0,0,512,512);
            ctx.strokeStyle='#da0'; ctx.lineWidth=20; ctx.strokeRect(20,20,472,472);
            ctx.fillStyle='#da0'; ctx.font='60px serif'; ctx.textAlign='center';
            ctx.fillText("HAPPY", 256, 220); ctx.fillText("HOLIDAYS", 256, 300);
            
            new THREE.TextureLoader().load(cvs.toDataURL(), t => {
                t.colorSpace = THREE.SRGBColorSpace;
                addPhotoToSceneImpl(t, "Welcome", "default");
            });
        }

        function addPhotoToScene(dataUrl, name, id) {
            return new Promise((resolve) => {
                new THREE.TextureLoader().load(
                    dataUrl,
                    (t) => {
                        t.colorSpace = THREE.SRGBColorSpace;
                        addPhotoToSceneImpl(t, name, id);
                        resolve();
                    },
                    undefined,
                    () => resolve() // Resolve on error so we don't block
                );
            });
        }

        function addPhotoToSceneImpl(tex, name, id) {
            const group = new THREE.Group();
            
            // Frame
            const frame = new THREE.Mesh(
                new THREE.BoxGeometry(1.2, 1.2, 0.05),
                new THREE.MeshStandardMaterial({color: CONFIG.colors.gold})
            );
            // Image
            const img = new THREE.Mesh(
                new THREE.PlaneGeometry(1, 1),
                new THREE.MeshBasicMaterial({map: tex, transparent: true})
            );
            img.position.z = 0.03;
            
            group.add(frame);
            group.add(img);
            photoGroup.add(group);

            const p = new Particle(group, 'PHOTO');
            p.id = id;
            p.name = name;
            particles.push(p);
            photoParticles.push(p);
        }

        // --- 4. AI & GESTURES ---
        async function initMediaPipe() {
            const video = document.getElementById('webcam');
            
            // Safety check for file protocol
            if (window.location.protocol === 'file:') {
                throw new Error("Cameras don't work in file:// mode. Please use a local server.");
            }

            const vision = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
            );
            
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numHands: 1
            });

            const stream = await navigator.mediaDevices.getUserMedia({ video: true });
            video.srcObject = stream;
            
            // Start prediction loop
            video.addEventListener("loadeddata", () => {
                predict();
            });
        }

        let lastTime = -1;
        function predict() {
            const video = document.getElementById('webcam');
            if (handLandmarker && video.currentTime !== lastTime) {
                lastTime = video.currentTime;
                const result = handLandmarker.detectForVideo(video, performance.now());
                
                if (result.landmarks.length > 0) {
                    STATE.handDetected = true;
                    handleGesture(result.landmarks[0]);
                } else {
                    STATE.handDetected = false;
                }
            }
            requestAnimationFrame(predict);
        }

        function handleGesture(lm) {
            // Calculate Gesture
            const dist = (i, j) => Math.hypot(lm[i].x - lm[j].x, lm[i].y - lm[j].y);
            const pinch = dist(4, 8) < 0.05;
            const open = dist(8,0) > 0.4 && dist(12,0) > 0.4; // Rough check
            const fist = dist(8,0) < 0.2 && dist(12,0) < 0.2;

            // Map hand X position to Rotation
            const handX = (lm[9].x - 0.5) * -2; // Invert for mirror effect
            if (STATE.mode === 'SCATTER') {
                STATE.targetRotY = handX * 1.5;
            } else {
                STATE.targetRotY += 0.005; // Auto rotate
            }

            // State Logic
            if (STATE.mode === 'FOCUS') {
                if (fist) resetToTree();
                return;
            }

            if (open) setMode('SCATTER', "Scatter Mode (Wave Hand)");
            else if (fist) setMode('TREE', "Tree Mode");
            
            if (pinch && STATE.canPinch) {
                pickRandomGift();
            }
        }

        function setMode(m, text) {
            STATE.mode = m;
            document.getElementById('status-bar').innerText = text;
        }

        function pickRandomGift() {
            // Find undrawn photos
            const available = photoParticles.filter(p => !p.isDrawn);
            if (available.length === 0) return;

            const p = available[Math.floor(Math.random() * available.length)];
            p.isDrawn = true;
            STATE.mode = 'FOCUS';
            STATE.focusTarget = p.mesh;
            
            // Show Caption
            const cap = document.getElementById('center-caption');
            cap.innerText = p.name || "A Memory";
            cap.style.opacity = 1;
            document.getElementById('status-bar').innerText = "Make FIST to close";

            // Debounce
            STATE.canPinch = false;
            setTimeout(() => STATE.canPinch = true, 2000);
        }

        function resetToTree() {
            STATE.mode = 'TREE';
            STATE.focusTarget = null;
            document.getElementById('center-caption').style.opacity = 0;
            document.getElementById('status-bar').innerText = "Tree Mode";
        }

        // --- 5. RENDER LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();

            // Smooth Rotation
            if (STATE.mode !== 'SCATTER') STATE.targetRotY += dt * 0.2;
            STATE.currentRotY += (STATE.targetRotY - STATE.currentRotY) * dt * 2;
            
            mainGroup.rotation.y = STATE.currentRotY;
            mainGroup.updateMatrixWorld();

            // Update Particles
            particles.forEach(p => p.update(dt));

            composer.render();
        }

        // --- 6. UI HANDLERS ---
        window.openGallery = function() {
            document.getElementById('gallery-modal').style.display = 'flex';
        };
        window.closeGallery = function() {
            document.getElementById('gallery-modal').style.display = 'none';
        };
        
        function updateGallery() {
            const grid = document.getElementById('gallery-grid');
            grid.innerHTML = '';
            const data = JSON.parse(localStorage.getItem(CONFIG.storageKey) || '[]');
            
            data.forEach(item => {
                const div = document.createElement('div');
                div.className = 'gallery-item';
                div.innerHTML = `<img src="${item.data}"><button class="del-btn" onclick="deletePhoto('${item.id}')">Ã—</button>`;
                grid.appendChild(div);
            });
        }
        
        window.deletePhoto = function(id) {
            if(!confirm("Delete?")) return;
            let data = JSON.parse(localStorage.getItem(CONFIG.storageKey) || '[]');
            data = data.filter(i => i.id !== id);
            localStorage.setItem(CONFIG.storageKey, JSON.stringify(data));
            
            // Remove from 3D scene immediately
            const idx = photoParticles.findIndex(p => p.id === id);
            if(idx > -1) {
                photoGroup.remove(photoParticles[idx].mesh);
                particles = particles.filter(p => p !== photoParticles[idx]);
                photoParticles.splice(idx, 1);
            }
            updateGallery();
        };

        // File Upload
        document.getElementById('input-file').addEventListener('change', async (e) => {
            const files = e.target.files;
            if(!files.length) return;

            let data = JSON.parse(localStorage.getItem(CONFIG.storageKey) || '[]');

            for(let f of files) {
                const reader = new FileReader();
                reader.onload = (ev) => {
                    const img = new Image();
                    img.onload = () => {
                        const cvs = document.createElement('canvas');
                        const s = Math.min(600/img.width, 600/img.height, 1);
                        cvs.width = img.width * s; cvs.height = img.height * s;
                        cvs.getContext('2d').drawImage(img,0,0,cvs.width,cvs.height);
                        
                        const item = {
                            id: Date.now() + Math.random(),
                            name: f.name.split('.')[0],
                            data: cvs.toDataURL('image/jpeg', 0.7)
                        };
                        data.push(item);
                        localStorage.setItem(CONFIG.storageKey, JSON.stringify(data));
                        
                        addPhotoToScene(item.data, item.name, item.id);
                        updateGallery();
                    };
                    img.src = ev.target.result;
                }
                reader.readAsDataURL(f);
            }
        });

        // Run Init
        init();

    </script>
</body>
</html>
